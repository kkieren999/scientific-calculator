<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>fx-82ES Canvas Mock</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #222;
      font-family: Arial, sans-serif;
    }
    body {
      display: flex;
      align-items: stretch;
      justify-content: stretch;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      image-rendering: crisp-edges;
    }
  </style>
</head>
<body>
<canvas id="calc"></canvas>

<script>
const canvas = document.getElementById("calc");
const ctx = canvas.getContext("2d");

// --- Logical drawing size (virtual canvas) -----------------------------
const LOGICAL_W = 480;
const LOGICAL_H = 760;
let currentScale = 1;
let offsetX = 0;
let offsetY = 0;

// --- Calculator state --------------------------------------------------
let expr = "";          // expression text shown at top-left
let result = "";        // result text (decimal)
let lastAnswer = "";    // for "Ans" button
let lastNumericResult = null; // numeric value of last evaluation
let resultIsFraction = false; // S↔D toggle state
let resultFraction = null;    // {n, d} when in fraction mode
let cursorPos = 0;      // insertion index in expr
let cursorVisible = true;

let pad = { cx: 0, cy: 0, outerR: 0, innerR: 0 }; // arrow pad geometry

// special tokens for structured fractions in the expression line
const FRACTION_START = "\uE000";
const FRACTION_SEP   = "\uE001";
const FRACTION_END   = "\uE002";
const PLACEHOLDER    = "□";

const baseFont  = "20px Arial";
const superFont = "14px Arial";
const PLACEHOLDER_WIDTH = 16 + 4; // box + padding

// --- Rounded rectangle helper ------------------------------------------
function roundedRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// --- Key definitions (layout + colours) -------------------------------
const keys = [
  // row 0 – yellow / pink / purple keys
  { row: 0, col: 0, label: "SHIFT", fill: "#6f6aa8", text: "#fff" },
  { row: 0, col: 1, label: "ALPHA", fill: "#6f6aa8", text: "#fff" },
  { row: 0, col: 4, label: "MODE", fill: "#6f6aa8", text: "#fff" },
  { row: 0, col: 5, label: "ON", fill: "#6f6aa8", text: "#fff" },

  // row 1 – trig / special
  { row: 1, col: 0, label: "Abs", fill: "#606070", text: "#fff" },
  { row: 1, col: 1, label: "x³", fill: "#606070", text: "#fff" },
  { row: 1, col: 4, label: "x⁻¹", fill: "#606070", text: "#fff" },
  { row: 1, col: 5, label: "log₁₀", fill: "#606070", text: "#fff" },

  // row 2 – top grey function row
  { row: 2, col: 0, label: "a/b", fill: "#606070", text: "#fff" },
  { row: 2, col: 1, label: "√",  fill: "#606070", text: "#fff" },
  { row: 2, col: 2, label: "x²", fill: "#606070", text: "#fff" },
  { row: 2, col: 3, label: "xⁿ", fill: "#606070", text: "#fff" },
  { row: 2, col: 4, label: "log", fill: "#606070", text: "#fff" },
  { row: 2, col: 5, label: "ln",  fill: "#606070", text: "#fff" },

  // row 3 – trig / special
  { row: 3, col: 0, label: "(—)", fill: "#606070", text: "#fff" },
  { row: 3, col: 1, label: "°'''", fill: "#606070", text: "#fff" },
  { row: 3, col: 2, label: "hyp", fill: "#606070", text: "#fff" },
  { row: 3, col: 3, label: "sin", fill: "#606070", text: "#fff" },
  { row: 3, col: 4, label: "cos", fill: "#606070", text: "#fff" },
  { row: 3, col: 5, label: "tan", fill: "#606070", text: "#fff" },

  // row 4 – memory / brackets
  { row: 4, col: 0, label: "RCL", fill: "#606070", text: "#fff" },
  { row: 4, col: 1, label: "ENG", fill: "#606070", text: "#fff" },
  { row: 4, col: 2, label: "(",   fill: "#606070", text: "#fff" },
  { row: 4, col: 3, label: ")",   fill: "#606070", text: "#fff" },
  { row: 4, col: 4, label: "S↔D", fill: "#606070", text: "#fff" },
  { row: 4, col: 5, label: "M+",  fill: "#606070", text: "#fff" },

  // row 5 – 7 8 9 DEL AC
  { row: 5, col: 0, label: "7",   fill: "#6c7084", text: "#fff" },
  { row: 5, col: 1, label: "8",   fill: "#6c7084", text: "#fff" },
  { row: 5, col: 2, label: "9",   fill: "#6c7084", text: "#fff" },
  { row: 5, col: 3, label: "DEL", fill: "#f2968f", text: "#000" },
  { row: 5, col: 4, label: "AC",  fill: "#f2968f", text: "#000" },

  // row 6 – 4 5 6 × ÷
  { row: 6, col: 0, label: "4",   fill: "#6c7084", text: "#fff" },
  { row: 6, col: 1, label: "5",   fill: "#6c7084", text: "#fff" },
  { row: 6, col: 2, label: "6",   fill: "#6c7084", text: "#fff" },
  { row: 6, col: 3, label: "×",   fill: "#6c7084", text: "#fff" },
  { row: 6, col: 4, label: "÷",   fill: "#6c7084", text: "#fff" },

  // row 7 – 1 2 3 + −
  { row: 7, col: 0, label: "1",   fill: "#6c7084", text: "#fff" },
  { row: 7, col: 1, label: "2",   fill: "#6c7084", text: "#fff" },
  { row: 7, col: 2, label: "3",   fill: "#6c7084", text: "#fff" },
  { row: 7, col: 3, label: "+",   fill: "#6c7084", text: "#fff" },
  { row: 7, col: 4, label: "—",   fill: "#6c7084", text: "#fff" },

  // row 8 – 0 . ×10^x Ans =
  { row: 8, col: 0, label: "0",    fill: "#6c7084", text: "#fff" },
  { row: 8, col: 1, label: ".",    fill: "#6c7084", text: "#fff" },
  { row: 8, col: 2, label: "×10ˣ", fill: "#6c7084", text: "#fff" },
  { row: 8, col: 3, label: "Ans",  fill: "#6c7084", text: "#fff" },
  { row: 8, col: 4, label: "=",    fill: "#62b6c8", text: "#fff" } // bluish equals
];

// --- Small helpers for drawing expression -----------------------------
function drawCursorAt(x, baselineY) {
  const cursorTop = baselineY - 22;
  const cursorBottom = baselineY + 4;
  ctx.beginPath();
  ctx.moveTo(x, cursorTop);
  ctx.lineTo(x, cursorBottom);
  ctx.lineWidth = 2;
  ctx.strokeStyle = "#000000";
  ctx.stroke();
}

function drawPlaceholderAt(x, baselineY) {
  const boxSize = 16;
  const boxTop = baselineY - 20;
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(x + 1, boxTop, boxSize, boxSize);
  ctx.strokeStyle = "#000000";
  ctx.lineWidth = 1;
  ctx.strokeRect(x + 1, boxTop, boxSize, boxSize);
  ctx.fillStyle = "#000000";
  return PLACEHOLDER_WIDTH;
}

// draw inline segment expr[start:end] on a single baseline
function drawInlineFromTo(start, end, baselineY, xStart) {
  let x = xStart;
  let i = start;

  while (i < end) {
    if (i === cursorPos && cursorVisible) {
      drawCursorAt(x, baselineY);
    }

    const ch = expr[i];

    // placeholder box
    if (ch === PLACEHOLDER) {
      x += drawPlaceholderAt(x, baselineY);
      i++;
      continue;
    }

    // power handling (^ + digits)
    if (ch === "^") {
      let j = i + 1;
      let expDigits = "";
      while (j < end && /[0-9]/.test(expr[j])) {
        expDigits += expr[j];
        j++;
      }

      if (expDigits.length === 0) {
        const boxW = 14;
        const boxH = 14;
        const boxY = baselineY - 20;
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 2, boxY, boxW, boxH);
        x += boxW + 4;
      } else {
        ctx.save();
        ctx.font = superFont;
        ctx.textBaseline = "alphabetic";
        const superY = baselineY - 10;
        ctx.fillStyle = "#000000";
        ctx.fillText(expDigits, x + 2, superY);
        x += ctx.measureText(expDigits).width + 4;
        ctx.restore();
      }
      i = j;
      continue;
    }

    // normal character
    ctx.save();
    ctx.font = baseFont;
    ctx.textBaseline = "alphabetic";
    ctx.fillStyle = "#000000";
    ctx.fillText(ch, x, baselineY);
    x += ctx.measureText(ch).width;
    ctx.restore();

    i++;
  }

  if (end === cursorPos && cursorVisible) {
    drawCursorAt(x, baselineY);
  }
  return x;
}

// measure width of inline segment expr[start:end]
function measureInlineWidth(start, end) {
  let width = 0;
  let i = start;
  ctx.save();
  ctx.font = baseFont;

  while (i < end) {
    const ch = expr[i];

    if (ch === PLACEHOLDER) {
      width += PLACEHOLDER_WIDTH;
      i++;
      continue;
    }

    if (ch === "^") {
      let j = i + 1;
      let expDigits = "";
      while (j < end && /[0-9]/.test(expr[j])) {
        expDigits += expr[j];
        j++;
      }
      if (expDigits.length === 0) {
        width += 14 + 4;
      } else {
        width += ctx.measureText(expDigits).width + 4;
      }
      i = j;
      continue;
    }

    width += ctx.measureText(ch).width;
    i++;
  }

  ctx.restore();
  return width;
}

// --- Expression drawing with superscripts, fraction template & cursor --
function drawExpression(screenX, screenY, screenW, screenH) {
  const marginX = 10;
  const baseY = screenY + 50;  // vertical position for main line
  let x = screenX + marginX;

  ctx.save();
  ctx.fillStyle = "#000";
  ctx.textBaseline = "alphabetic";
  ctx.font = baseFont;

  let i = 0;
  while (i < expr.length) {
    const ch = expr[i];

    // structured fraction: FRACTION_START num FRACTION_SEP den FRACTION_END
    if (ch === FRACTION_START) {
      const start = i;
      let sep = -1;
      let end = -1;

      for (let j = i + 1; j < expr.length; j++) {
        if (expr[j] === FRACTION_SEP && sep === -1) {
          sep = j;
        } else if (expr[j] === FRACTION_END) {
          end = j;
          break;
        }
      }

      if (sep === -1 || end === -1) {
        // malformed – just draw token as inline
        x = drawInlineFromTo(i, i + 1, baseY, x);
        i++;
        continue;
      }

      const numStart = start + 1;
      const numEnd = sep;
      const denStart = sep + 1;
      const denEnd = end;

      // width of numerator & denominator
      const numWidth = measureInlineWidth(numStart, numEnd);
      const denWidth = measureInlineWidth(denStart, denEnd);
      const fracWidth = Math.max(numWidth, denWidth) + 10; // padding

      const numX = x + (fracWidth - numWidth) / 2;
      const denX = x + (fracWidth - denWidth) / 2;
      const numBaseline = baseY - 12;
      const denBaseline = baseY + 14;

      // cursor just before fraction
      if (cursorPos === start && cursorVisible) {
        drawCursorAt(x, baseY);
      }

      // draw numerator & denominator segments
      drawInlineFromTo(numStart, numEnd, numBaseline, numX);
      drawInlineFromTo(denStart, denEnd, denBaseline, denX);

      // vinculum
      ctx.beginPath();
      ctx.moveTo(x, baseY - 10);
      ctx.lineTo(x + fracWidth, baseY - 10);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#000000";
      ctx.stroke();

      x += fracWidth;
      i = end + 1;
      continue;
    }

    // normal inline character (includes placeholders, powers, etc.)
    x = drawInlineFromTo(i, i + 1, baseY, x);
    i++;
  }

  if (cursorPos === expr.length && cursorVisible) {
    drawCursorAt(x, baseY);
  }

  ctx.restore();
}

// --- Result drawing: decimal OR fraction (for S↔D) --------------------
function drawResult(screenX, screenY, screenW, screenH) {
  if (!result && !resultIsFraction) return;

  const xRight = screenX + screenW - 10;
  const yBase = screenY + screenH - 20;

  ctx.save();
  ctx.fillStyle = "#000";
  ctx.textBaseline = "alphabetic";
  ctx.font = baseFont;

  if (resultIsFraction && resultFraction) {
    const numStr = String(resultFraction.n);
    const denStr = String(resultFraction.d);

    const numW = ctx.measureText(numStr).width;
    const denW = ctx.measureText(denStr).width;
    const fracWidth = Math.max(numW, denW) + 10;

    const xLeft = xRight - fracWidth;
    const numBaseline = yBase - 12;
    const denBaseline = yBase + 14;

    const numX = xLeft + (fracWidth - numW) / 2;
    const denX = xLeft + (fracWidth - denW) / 2;

    ctx.fillText(numStr, numX, numBaseline);
    ctx.fillText(denStr, denX, denBaseline);

    // vinculum
    ctx.beginPath();
    ctx.moveTo(xLeft, yBase - 10);
    ctx.lineTo(xLeft + fracWidth, yBase - 10);
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#000";
    ctx.stroke();
  } else {
    ctx.textAlign = "right";
    ctx.textBaseline = "bottom";
    ctx.font = "bold 22px Arial";
    const y = screenY + screenH - 10;
    ctx.fillText(result, xRight, y);
  }

  ctx.restore();
}

// --- Main drawing of calculator ---------------------------------------
function drawCalculator() {
  const W = LOGICAL_W;
  const H = LOGICAL_H;

  // background behind calculator
  ctx.fillStyle = "#303040";
  ctx.fillRect(0, 0, W, H);

  // calculator body
  const margin = 20;
  const bodyRadius = 30;
  roundedRect(ctx, margin, margin, W - 2 * margin, H - 2 * margin, bodyRadius);
  ctx.fillStyle = "#4e4c69";
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "#202030";
  ctx.stroke();

  // screen
  const screenX = margin + 20;
  const screenY = margin + 25;
  const screenW = W - 2 * (margin + 20);
  const screenH = 90;
  roundedRect(ctx, screenX, screenY, screenW, screenH, 8);
  ctx.fillStyle = "#c4dfb3"; // pale green display
  ctx.fill();
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = "#6b8164";
  ctx.stroke();

  // branding
  ctx.fillStyle = "#f5f5f5";
  ctx.font = "bold 14px Arial";
  ctx.textAlign = "left";
  ctx.textBaseline = "alphabetic";
  ctx.fillText("KDOG", screenX, screenY - 8);

  ctx.font = "10px Arial";
  ctx.fillText("SCIENTIFIC CALCULATOR", screenX, screenY + screenH + 12);

  ctx.fillStyle = "#7fd3c6";
  ctx.font = "bold 16px Arial";
  ctx.fillText("CALCULATOR", screenX + screenW - 160, screenY - 8);

  // draw expression + result inside screen
  drawExpression(screenX, screenY, screenW, screenH);
  drawResult(screenX, screenY, screenW, screenH);

  // replay circular pad
  const padCX = W / 2;
  const padCY = screenY + screenH + 55;
  const padR = 40;
  pad.cx = padCX;
  pad.cy = padCY;
  pad.outerR = padR;
  pad.innerR = padR - 8;

  // outer ring
  ctx.beginPath();
  ctx.arc(padCX, padCY, padR, 0, Math.PI * 2);
  ctx.fillStyle = "#5b5a7a";
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "#2c2b3b";
  ctx.stroke();

  // inner ring
  ctx.beginPath();
  ctx.arc(padCX, padCY, padR - 8, 0, Math.PI * 2);
  ctx.fillStyle = "#5f5e80";
  ctx.fill();
  ctx.lineWidth = 1;
  ctx.strokeStyle = "#707090";
  ctx.stroke();

  // arrow symbols
  ctx.fillStyle = "#f5f5f5";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.font = "bold 14px Arial";
  ctx.fillText("▲", padCX, padCY - 20);
  ctx.fillText("▼", padCX, padCY + 22);
  ctx.fillText("◄", padCX - 20, padCY + 2);
  ctx.fillText("►", padCX + 20, padCY + 2);
  ctx.textAlign = "left";
  ctx.textBaseline = "alphabetic";

  // keys layout
  const startY = padCY - 30;
  const startX = margin + 18;
  const colGap = 8;
  const rowGap = 10;
  const keyW = 60;
  const keyH = 44;

  // for alignment: full width of a 6-column row (rows 0–4)
  const totalColsFull = 6;
  const fullRowWidth = totalColsFull * keyW + (totalColsFull - 1) * colGap;

  // rows 5–8 have 5 keys; make them wider so they fill the same width
  const wideRowCols = 5;
  const wideKeyW = (fullRowWidth - (wideRowCols - 1) * colGap) / wideRowCols;

  keys.forEach(key => {
    const isWideRow = key.row >= 5; // rows 5–8
    const thisKeyW = isWideRow ? wideKeyW : keyW;

    const x = startX + key.col * (thisKeyW + colGap);
    const y = startY + key.row * (keyH + rowGap);

    key.x = x;
    key.y = y;
    key.w = thisKeyW;
    key.h = keyH;

    roundedRect(ctx, x, y, thisKeyW, keyH, 5);
    ctx.fillStyle = key.fill;
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#1e1e28";
    ctx.stroke();

    // Special drawing for the fraction key label: tiny two-box fraction icon
    if (key.label === "a/b") {
      const cx = x + thisKeyW / 2;
      const cy = y + keyH / 2;
      const boxW = 14;
      const boxH = 10;

      // numerator box
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(cx - boxW / 2, cy - 9 - boxH, boxW, boxH);
      ctx.strokeStyle = "#000000";
      ctx.strokeRect(cx - boxW / 2, cy - 9 - boxH, boxW, boxH);

      // denominator box
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(cx - boxW / 2, cy + 3, boxW, boxH);
      ctx.strokeStyle = "#000000";
      ctx.strokeRect(cx - boxW / 2, cy + 3, boxW, boxH);

      // vinculum
      ctx.beginPath();
      ctx.moveTo(cx - boxW / 2 - 2, cy - 2);
      ctx.lineTo(cx + boxW / 2 + 2, cy - 2);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#000000";
      ctx.stroke();
    } else {
      ctx.fillStyle = key.text;
      ctx.font = "bold 14px Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(key.label, x + thisKeyW / 2, y + keyH / 2 + 1);
    }
  });

  // reset text state
  ctx.textAlign = "left";
  ctx.textBaseline = "alphabetic";
}

// --- Expression helpers -----------------------------------------------
function insertText(text) {
  // If we're sitting on a placeholder and typing a single digit/decimal,
  // REPLACE the box instead of inserting before it.
  if (
    expr[cursorPos] === PLACEHOLDER &&
    text.length === 1 &&
    /[0-9.]/.test(text)
  ) {
    expr = expr.slice(0, cursorPos) + text + expr.slice(cursorPos + 1);
    cursorPos += text.length;
  } else {
    expr = expr.slice(0, cursorPos) + text + expr.slice(cursorPos);
    cursorPos += text.length;
  }
}

function deleteChar() {
  if (cursorPos > 0) {
    expr = expr.slice(0, cursorPos - 1) + expr.slice(cursorPos);
    cursorPos--;
  }
}

function clearAll() {
  expr = "";
  result = "";
  lastNumericResult = null;
  resultIsFraction = false;
  resultFraction = null;
  cursorPos = 0;
}

// Convert fractions from internal tokens to JS "(/)" form
function convertFractionsToEval(s) {
  let out = "";
  for (let i = 0; i < s.length; i++) {
    const ch = s[i];
    if (ch === FRACTION_START) {
      let sep = -1;
      let end = -1;
      for (let j = i + 1; j < s.length; j++) {
        if (s[j] === FRACTION_SEP && sep === -1) {
          sep = j;
        } else if (s[j] === FRACTION_END) {
          end = j;
          break;
        }
      }
      if (sep === -1 || end === -1) {
        // malformed – skip this token
        continue;
      }
      let num = s.slice(i + 1, sep).replace(new RegExp(PLACEHOLDER, "g"), "");
      let den = s.slice(sep + 1, end).replace(new RegExp(PLACEHOLDER, "g"), "");

      if (!num) num = "0";
      if (!den) den = "1";

      out += "(" + num + ")/(" + den + ")";
      i = end;
    } else if (ch === FRACTION_SEP || ch === FRACTION_END) {
      // shouldn't appear alone – ignore
    } else {
      out += ch;
    }
  }
  return out;
}

// degree-based trig + logs ---------------------------------------------
function degSin(x) { return Math.sin(x * Math.PI / 180); }
function degCos(x) { return Math.cos(x * Math.PI / 180); }
function degTan(x) { return Math.tan(x * Math.PI / 180); }
function log10(x) {
  return Math.log10 ? Math.log10(x) : Math.log(x) / Math.LN10;
}

// Convert display expr → JS-evaluable string
function buildEvalString() {
  let s = expr;

  // convert structured fractions first
  s = convertFractionsToEval(s);

  // strip any remaining placeholders
  s = s.replace(new RegExp(PLACEHOLDER, "g"), "");

  // implicit multiplication: digit or ")" followed by "("
  s = s.replace(/(\d|\))\(/g, "$1*(");

  // replace nice symbols with JS-friendly ones
  s = s.replace(/×/g, "*")
       .replace(/÷/g, "/")
       .replace(/—/g, "-");

  // square root "√(" -> Math.sqrt(
  s = s.replace(/√\s*\(/g, "Math.sqrt(");

  // exponent: ^ -> **
  s = s.replace(/\^/g, "**");

  // trig & logs in degrees:
  // sin(θ) -> degSin(θ), etc
  s = s.replace(/sin\(/g, "degSin(")
       .replace(/cos\(/g, "degCos(")
       .replace(/tan\(/g, "degTan(")
       .replace(/log\(/g, "log10(")
       .replace(/ln\(/g, "Math.log(");

  return s;
}

function hasDanglingPower() {
  // "^" at end or "^" not followed by a digit
  for (let i = 0; i < expr.length; i++) {
    if (expr[i] === "^") {
      const next = expr[i + 1];
      if (!next || !/[0-9]/.test(next)) return true;
    }
  }
  return false;
}

function formatDecimal(x) {
  if (!Number.isFinite(x)) return "Error";
  let s = x.toString();
  if (s.length > 12) {
    s = x.toPrecision(10);
  }
  return s;
}

function evaluateExpression() {
  if (!expr) {
    result = "";
    lastNumericResult = null;
    resultIsFraction = false;
    resultFraction = null;
    return;
  }

  if (hasDanglingPower()) {
    result = "Error";
    lastNumericResult = null;
    resultIsFraction = false;
    resultFraction = null;
    return;
  }

  let evalStr = buildEvalString();
  try {
    const fn = Function('"use strict"; return (' + evalStr + ');');
    let val = fn();
    if (typeof val === "number" && Number.isFinite(val)) {
      lastNumericResult = val;
      result = formatDecimal(val);
      lastAnswer = result;
      resultIsFraction = false;
      resultFraction = null;
    } else {
      result = "Error";
      lastNumericResult = null;
      resultIsFraction = false;
      resultFraction = null;
    }
  } catch (e) {
    result = "Error";
    lastNumericResult = null;
    resultIsFraction = false;
    resultFraction = null;
  }
}

// --- Decimal <-> fraction conversion for S↔D -------------------------
function decimalToFraction(x) {
  let num = Number(x);
  if (!Number.isFinite(num)) return null;

  const sign = num < 0 ? -1 : 1;
  num = Math.abs(num);

  const tol = 1e-8;
  const maxDen = 10000;

  if (Math.abs(num - Math.round(num)) < tol) {
    return { n: sign * Math.round(num), d: 1 };
  }

  let h1 = 1, h2 = 0;
  let k1 = 0, k2 = 1;
  let b = num;

  while (true) {
    const a = Math.floor(b);
    const h = a * h1 + h2;
    const k = a * k1 + k2;

    if (k > maxDen) break;

    h2 = h1; h1 = h;
    k2 = k1; k1 = k;

    const frac = b - a;
    if (frac < tol) break;
    b = 1 / frac;
  }

  return { n: sign * h1, d: k1 };
}

function toggleSD() {
  if (lastNumericResult == null) return;

  if (!resultIsFraction) {
    const frac = decimalToFraction(lastNumericResult);
    if (!frac) return;
    resultIsFraction = true;
    resultFraction = frac;
  } else {
    resultIsFraction = false;
    resultFraction = null;
    result = formatDecimal(lastNumericResult);
  }
}

// --- Fraction context helper for up/down movement ---------------------
function getFractionContext(pos) {
  for (let i = 0; i < expr.length; i++) {
    if (expr[i] === FRACTION_START) {
      const start = i;
      let sep = -1;
      let end = -1;
      for (let j = i + 1; j < expr.length; j++) {
        if (expr[j] === FRACTION_SEP && sep === -1) {
          sep = j;
        } else if (expr[j] === FRACTION_END) {
          end = j;
          break;
        }
      }
      if (sep === -1 || end === -1) {
        return null;
      }

      if (pos > start && pos < sep) {
        return { start, sep, end, region: "num" };
      }
      if (pos > sep && pos < end) {
        return { start, sep, end, region: "den" };
      }
      if (pos === sep) {
        return { start, sep, end, region: "bar" };
      }
      i = end;
    }
  }
  return null;
}

// --- Handle key labels -------------------------------------------------
function handleKey(label) {
  switch (label) {
    // digits & basic symbols (including minus key)
    case "0": case "1": case "2": case "3":
    case "4": case "5": case "6":
    case "7": case "8": case "9":
    case ".": case "+": case "—":
    case "×": case "÷":
    case "(": case ")":
      insertText(label);
      break;

    // negative sign key on row 3, col 0 – just insert the minus symbol
    case "(—)":
      insertText("—");
      break;

    // fraction template: structured fraction with two placeholders
    case "a/b": {
      const oldPos = cursorPos;
      const template =
        FRACTION_START +
        PLACEHOLDER +
        FRACTION_SEP +
        PLACEHOLDER +
        FRACTION_END;
      insertText(template);
      // move cursor into the top placeholder
      cursorPos = oldPos + 1;
      break;
    }

    // S <-> D toggle (supports both old "S<>D" and current "S↔D" label)
    case "S<>D":
    case "S↔D":
      toggleSD();
      break;

    // answer recall
    case "Ans":
      if (lastAnswer) insertText(lastAnswer);
      break;

    // clear & delete
    case "AC":
      clearAll();
      break;
    case "DEL":
      deleteChar();
      break;

    // square root -> "√("
    case "√":
      insertText("√(");
      break;

    // x^2 -> "^2"
    case "x²":
      insertText("^2");
      break;

    // x^n -> just "^" (placeholder box drawn if no exponent yet)
    case "xⁿ":
      insertText("^");
      break;

    // trig and logs (always degrees for trig)
    case "sin":
      insertText("sin(");
      break;
    case "cos":
      insertText("cos(");
      break;
    case "tan":
      insertText("tan(");
      break;
    case "log":
      insertText("log(");   // base-10
      break;
    case "log₁₀":
      insertText("log(");   // same as log
      break;
    case "ln":
      insertText("ln(");    // natural log
      break;

    // equals -> evaluate expression
    case "=":
      evaluateExpression();
      break;

    // ignoring for now
    default:
      // SHIFT, ALPHA, MODE, etc – no-op for now
      break;
  }
}

// --- Coordinate helper: map mouse to logical coords -------------------
function getLogicalCoords(e) {
  const rect = canvas.getBoundingClientRect();
  const cssX = e.clientX - rect.left;
  const cssY = e.clientY - rect.top;
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const internalX = cssX * scaleX;
  const internalY = cssY * scaleY;

  const lx = (internalX - offsetX) / currentScale;
  const ly = (internalY - offsetY) / currentScale;
  return { x: lx, y: ly };
}

// --- Mouse interaction: keys + arrow pad ------------------------------
canvas.addEventListener("click", (e) => {
  const { x: mx, y: my } = getLogicalCoords(e);

  // Check arrow pad ring region first
  const dx = mx - pad.cx;
  const dy = my - pad.cy;
  const dist = Math.sqrt(dx*dx + dy*dy);

  if (dist <= pad.outerR && dist >= pad.outerR * 0.4) {
    // Rough directional selection
    if (Math.abs(dx) > Math.abs(dy)) {
      // left / right
      if (dx < 0) {
        if (cursorPos > 0) cursorPos--;
      } else {
        if (cursorPos < expr.length) cursorPos++;
      }
    } else {
      // up / down – move between numerator & denominator if in a fraction,
      // otherwise home/end.
      const frac = getFractionContext(cursorPos);
      if (frac) {
        if (dy < 0) {
          // go to numerator slot
          cursorPos = frac.start + 1; // start of numerator
        } else {
          // go to denominator slot
          cursorPos = frac.sep + 1;   // start of denominator
        }
      } else {
        if (dy < 0) {
          cursorPos = 0;           // up -> go to start
        } else {
          cursorPos = expr.length; // down -> go to end
        }
      }
    }
    render();
    return;
  }

  // Otherwise, see if they clicked a key
  for (const key of keys) {
    if (!key.w) continue; // not laid out yet
    if (
      mx >= key.x && mx <= key.x + key.w &&
      my >= key.y && my <= key.y + key.h
    ) {
      handleKey(key.label);
      render();
      return;
    }
  }
});

// --- Keyboard support --------------------------------------------------
document.addEventListener("keydown", (e) => {
  const k = e.key;

  if (k === "ArrowLeft") {
    if (cursorPos > 0) cursorPos--;
    render();
    e.preventDefault();
  } else if (k === "ArrowRight") {
    if (cursorPos < expr.length) cursorPos++;
    render();
    e.preventDefault();
  } else if (k === "ArrowUp") {
    const frac = getFractionContext(cursorPos);
    if (frac) {
      cursorPos = frac.start + 1; // numerator start
    } else {
      cursorPos = 0; // home
    }
    render();
    e.preventDefault();
  } else if (k === "ArrowDown") {
    const frac = getFractionContext(cursorPos);
    if (frac) {
      cursorPos = frac.sep + 1; // denominator start
    } else {
      cursorPos = expr.length; // end
    }
    render();
    e.preventDefault();
  } else if (k === "Backspace") {
    deleteChar();
    render();
    e.preventDefault();
  } else if (k === "Enter" || k === "=") {
    evaluateExpression();
    render();
    e.preventDefault();
  } else if (/[0-9]/.test(k)) {
    insertText(k);
    render();
  } else if (k === "+") {
    insertText("+");
    render();
  } else if (k === "-") {
    insertText("—"); // use the calculator-style minus
    render();
  } else if (k === "*") {
    insertText("×");
    render();
  } else if (k === "/") {
    // keyboard "/" still behaves as ÷ for normal division
    insertText("÷");
    render();
  } else if (k === ".") {
    insertText(".");
    render();
  } else if (k === "(" || k === ")") {
    insertText(k);
    render();
  } else if (k === "^") {
    insertText("^");
    render();
  }
});

// --- Render loop (for blinking cursor) --------------------------------
function render() {
  // reset transform, clear whole physical canvas, then re-apply scaling
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.translate(offsetX, offsetY);
  ctx.scale(currentScale, currentScale);
  drawCalculator();
}

// blink cursor
setInterval(() => {
  cursorVisible = !cursorVisible;
  render();
}, 500);

// --- Resize handling: responsive full-screen canvas -------------------
function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1;
  const width = window.innerWidth;
  const height = window.innerHeight;

  canvas.width = width * dpr;
  canvas.height = height * dpr;

  const scaleX = canvas.width / LOGICAL_W;
  const scaleY = canvas.height / LOGICAL_H;
  currentScale = Math.min(scaleX, scaleY);

  offsetX = (canvas.width - LOGICAL_W * currentScale) / 2;
  offsetY = (canvas.height - LOGICAL_H * currentScale) / 2;

  render();
}

window.addEventListener("resize", resizeCanvas);

// initial draw
resizeCanvas();
</script>
</body>
</html>
