<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fx-82ES Canvas Mock</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #222;
      font-family: Arial, sans-serif;
    }
    body {
      overflow: hidden; /* stop scrolling on mobile */
    }
    canvas {
      display: block;
      image-rendering: crisp-edges;
      touch-action: manipulation; /* helps prevent double-tap zoom */
    }
  </style>
</head>
<body>
<canvas id="calc"></canvas>

<script>
// Logical design size (everything is drawn in this coordinate system)
const DESIGN_WIDTH  = 480;
const DESIGN_HEIGHT = 760;

const canvas = document.getElementById("calc");
const ctx = canvas.getContext("2d");

// --- Global transform for responsive scaling ---------------------------
let scale = 1;
let offsetX = 0;
let offsetY = 0;

// --- Calculator state --------------------------------------------------
let expr = "";          // expression text shown at top-left
let result = "";        // result text shown bottom-right
let lastAnswer = "";    // for "Ans" button
let cursorPos = 0;      // insertion index in expr
let cursorVisible = true;

let pad = { cx: 0, cy: 0, outerR: 0, innerR: 0 }; // arrow pad geometry

// special tokens for structured fractions
const FRACTION_START = "\uE000";
const FRACTION_SEP   = "\uE001";
const FRACTION_END   = "\uE002";
const PLACEHOLDER    = "□";

const baseFont  = "20px Arial";
const superFont = "14px Arial";
const PLACEHOLDER_WIDTH = 16 + 4; // box + padding

// --- Rounded rectangle helper ------------------------------------------
function roundedRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// --- Key definitions (layout + colours) -------------------------------
const keys = [
  // row 0 – yellow / pink / purple keys
  { row: 0, col: 0, label: "SHIFT", fill: "#f7d46a", text: "#333" },
  { row: 0, col: 1, label: "ALPHA", fill: "#f2b0b0", text: "#333" },
  { row: 0, col: 2, label: "MODE",  fill: "#6f6aa8", text: "#fff" },
  { row: 0, col: 3, label: "SETUP", fill: "#6f6aa8", text: "#fff" },
  { row: 0, col: 4, label: "ON",    fill: "#6f6aa8", text: "#fff" },
  { row: 0, col: 5, label: "OFF",   fill: "#6f6aa8", text: "#fff" },

  // row 1 – top grey function row
  { row: 1, col: 0, label: "a/b", fill: "#606070", text: "#fff" },
  { row: 1, col: 1, label: "√",   fill: "#606070", text: "#fff" },
  { row: 1, col: 2, label: "x²",  fill: "#606070", text: "#fff" },
  { row: 1, col: 3, label: "xⁿ",  fill: "#606070", text: "#fff" },
  { row: 1, col: 4, label: "log", fill: "#606070", text: "#fff" },
  { row: 1, col: 5, label: "ln",  fill: "#606070", text: "#fff" },

  // row 2 – trig / special
  { row: 2, col: 0, label: "(—)", fill: "#606070", text: "#fff" },
  { row: 2, col: 1, label: "'''", fill: "#606070", text: "#fff" },
  { row: 2, col: 2, label: "hyp", fill: "#606070", text: "#fff" },
  { row: 2, col: 3, label: "sin", fill: "#606070", text: "#fff" },
  { row: 2, col: 4, label: "cos", fill: "#606070", text: "#fff" },
  { row: 2, col: 5, label: "tan", fill: "#606070", text: "#fff" },

  // row 3 – memory / brackets
  { row: 3, col: 0, label: "RCL", fill: "#606070", text: "#fff" },
  { row: 3, col: 1, label: "ENG", fill: "#606070", text: "#fff" },
  { row: 3, col: 2, label: "(",   fill: "#606070", text: "#fff" },
  { row: 3, col: 3, label: ")",   fill: "#606070", text: "#fff" },
  { row: 3, col: 4, label: "S<>D",fill: "#606070", text: "#fff" },
  { row: 3, col: 5, label: "M+",  fill: "#f2968f", text: "#000" },

  // row 4 – 7 8 9 DEL AC
  { row: 4, col: 0, label: "7",   fill: "#6c7084", text: "#fff" },
  { row: 4, col: 1, label: "8",   fill: "#6c7084", text: "#fff" },
  { row: 4, col: 2, label: "9",   fill: "#6c7084", text: "#fff" },
  { row: 4, col: 3, label: "DEL", fill: "#f2968f", text: "#000" },
  { row: 4, col: 4, label: "AC",  fill: "#6c7084", text: "#fff" },

  // row 5 – 4 5 6 × ÷
  { row: 5, col: 0, label: "4",   fill: "#6c7084", text: "#fff" },
  { row: 5, col: 1, label: "5",   fill: "#6c7084", text: "#fff" },
  { row: 5, col: 2, label: "6",   fill: "#6c7084", text: "#fff" },
  { row: 5, col: 3, label: "×",   fill: "#6c7084", text: "#fff" },
  { row: 5, col: 4, label: "÷",   fill: "#6c7084", text: "#fff" },

  // row 6 – 1 2 3 + −
  { row: 6, col: 0, label: "1",   fill: "#6c7084", text: "#fff" },
  { row: 6, col: 1, label: "2",   fill: "#6c7084", text: "#fff" },
  { row: 6, col: 2, label: "3",   fill: "#6c7084", text: "#fff" },
  { row: 6, col: 3, label: "+",   fill: "#6c7084", text: "#fff" },
  { row: 6, col: 4, label: "—",   fill: "#6c7084", text: "#fff" },

  // row 7 – 0 . ×10^x Ans =
  { row: 7, col: 0, label: "0",    fill: "#6c7084", text: "#fff" },
  { row: 7, col: 1, label: ".",    fill: "#6c7084", text: "#fff" },
  { row: 7, col: 2, label: "×10ˣ", fill: "#6c7084", text: "#fff" },
  { row: 7, col: 3, label: "Ans",  fill: "#6c7084", text: "#fff" },
  { row: 7, col: 4, label: "=",    fill: "#62b6c8", text: "#fff" } // bluish equals
];

// --- Small helpers for drawing expression -----------------------------
function drawCursorAt(x, baselineY) {
  const cursorTop = baselineY - 22;
  const cursorBottom = baselineY + 4;
  ctx.beginPath();
  ctx.moveTo(x, cursorTop);
  ctx.lineTo(x, cursorBottom);
  ctx.lineWidth = 2;
  ctx.strokeStyle = "#000000";
  ctx.stroke();
}

function drawPlaceholderAt(x, baselineY) {
  const boxSize = 16;
  const boxTop = baselineY - 20;
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(x + 1, boxTop, boxSize, boxSize);
  ctx.strokeStyle = "#000000";
  ctx.lineWidth = 1;
  ctx.strokeRect(x + 1, boxTop, boxSize, boxSize);
  ctx.fillStyle = "#000000";
  return PLACEHOLDER_WIDTH;
}

// draw inline segment expr[start:end] on a single baseline
function drawInlineFromTo(start, end, baselineY, xStart) {
  let x = xStart;
  let i = start;

  while (i < end) {
    if (i === cursorPos && cursorVisible) {
      drawCursorAt(x, baselineY);
    }

    const ch = expr[i];

    // placeholder box
    if (ch === PLACEHOLDER) {
      x += drawPlaceholderAt(x, baselineY);
      i++;
      continue;
    }

    // power handling (^ + digits)
    if (ch === "^") {
      let j = i + 1;
      let expDigits = "";
      while (j < end && /[0-9]/.test(expr[j])) {
        expDigits += expr[j];
        j++;
      }

      if (expDigits.length === 0) {
        const boxW = 14;
        const boxH = 14;
        const boxY = baselineY - 20;
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1;
        ctx.strokeRect(x + 2, boxY, boxW, boxH);
        x += boxW + 4;
      } else {
        ctx.save();
        ctx.font = superFont;
        ctx.textBaseline = "alphabetic";
        const superY = baselineY - 10;
        ctx.fillStyle = "#000000";
        ctx.fillText(expDigits, x + 2, superY);
        x += ctx.measureText(expDigits).width + 4;
        ctx.restore();
      }
      i = j;
      continue;
    }

    // normal character
    ctx.save();
    ctx.font = baseFont;
    ctx.textBaseline = "alphabetic";
    ctx.fillStyle = "#000000";
    ctx.fillText(ch, x, baselineY);
    x += ctx.measureText(ch).width;
    ctx.restore();

    i++;
  }

  if (end === cursorPos && cursorVisible) {
    drawCursorAt(x, baselineY);
  }
  return x;
}

// measure width of inline segment expr[start:end]
function measureInlineWidth(start, end) {
  let width = 0;
  let i = start;
  ctx.save();
  ctx.font = baseFont;

  while (i < end) {
    const ch = expr[i];

    if (ch === PLACEHOLDER) {
      width += PLACEHOLDER_WIDTH;
      i++;
      continue;
    }

    if (ch === "^") {
      let j = i + 1;
      let expDigits = "";
      while (j < end && /[0-9]/.test(expr[j])) {
        expDigits += expr[j];
        j++;
      }
      if (expDigits.length === 0) {
        width += 14 + 4;
      } else {
        width += ctx.measureText(expDigits).width + 4;
      }
      i = j;
      continue;
    }

    width += ctx.measureText(ch).width;
    i++;
  }

  ctx.restore();
  return width;
}

// --- Expression drawing with superscripts, fraction template & cursor --
function drawExpression(screenX, screenY, screenW, screenH) {
  const marginX = 10;
  const baseY = screenY + 50;  // vertical position for main line
  let x = screenX + marginX;

  ctx.save();
  ctx.fillStyle = "#000";
  ctx.textBaseline = "alphabetic";
  ctx.font = baseFont;

  let i = 0;
  while (i < expr.length) {
    const ch = expr[i];

    // structured fraction: FRACTION_START num FRACTION_SEP den FRACTION_END
    if (ch === FRACTION_START) {
      const start = i;
      let sep = -1;
      let end = -1;

      for (let j = i + 1; j < expr.length; j++) {
        if (expr[j] === FRACTION_SEP && sep === -1) {
          sep = j;
        } else if (expr[j] === FRACTION_END) {
          end = j;
          break;
        }
      }

      if (sep === -1 || end === -1) {
        // malformed – just draw token as a blank box-ish char
        x = drawInlineFromTo(i, i + 1, baseY, x);
        i++;
        continue;
      }

      const numStart = start + 1;
      const numEnd = sep;
      const denStart = sep + 1;
      const denEnd = end;

      // width of numerator & denominator
      const numWidth = measureInlineWidth(numStart, numEnd);
      const denWidth = measureInlineWidth(denStart, denEnd);
      const fracWidth = Math.max(numWidth, denWidth) + 10; // padding

      const numX = x + (fracWidth - numWidth) / 2;
      const denX = x + (fracWidth - denWidth) / 2;
      const numBaseline = baseY - 12;
      const denBaseline = baseY + 14;

      // cursor just before fraction
      if (cursorPos === start && cursorVisible) {
        drawCursorAt(x, baseY);
      }

      // draw numerator & denominator segments
      drawInlineFromTo(numStart, numEnd, numBaseline, numX);
      drawInlineFromTo(denStart, denEnd, denBaseline, denX);

      // vinculum
      ctx.beginPath();
      ctx.moveTo(x, baseY - 10);
      ctx.lineTo(x + fracWidth, baseY - 10);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#000000";
      ctx.stroke();

      x += fracWidth;
      i = end + 1;
      continue;
    }

    // normal inline character (includes placeholders, powers, etc.)
    x = drawInlineFromTo(i, i + 1, baseY, x);
    i++;
  }

  if (cursorPos === expr.length && cursorVisible) {
    drawCursorAt(x, baseY);
  }

  ctx.restore();
}

function drawResult(screenX, screenY, screenW, screenH) {
  if (!result) return;
  ctx.save();
  ctx.fillStyle = "#000";
  ctx.textAlign = "right";
  ctx.textBaseline = "bottom";
  ctx.font = "bold 22px Arial";
  const x = screenX + screenW - 10;
  const y = screenY + screenH - 10;
  ctx.fillText(result, x, y);
  ctx.textAlign = "left";
  ctx.textBaseline = "alphabetic";
  ctx.restore();
}

// --- Main drawing of calculator ---------------------------------------
function drawCalculator() {
  const W = DESIGN_WIDTH;
  const H = DESIGN_HEIGHT;

  // background behind calculator
  ctx.fillStyle = "#303040";
  ctx.fillRect(0, 0, W, H);

  // calculator body
  const margin = 20;
  const bodyRadius = 30;
  roundedRect(ctx, margin, margin, W - 2 * margin, H - 2 * margin, bodyRadius);
  ctx.fillStyle = "#4e4c69";
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "#202030";
  ctx.stroke();

  // screen
  const screenX = margin + 20;
  const screenY = margin + 25;
  const screenW = W - 2 * (margin + 20);
  const screenH = 90;
  roundedRect(ctx, screenX, screenY, screenW, screenH, 8);
  ctx.fillStyle = "#c4dfb3"; // pale green display
  ctx.fill();
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = "#6b8164";
  ctx.stroke();

  // branding
  ctx.fillStyle = "#f5f5f5";
  ctx.font = "bold 14px Arial";
  ctx.textAlign = "left";
  ctx.textBaseline = "alphabetic";
  ctx.fillText("CASIO", screenX, screenY - 8);

  ctx.font = "10px Arial";
  ctx.fillText("SCIENTIFIC CALCULATOR fx-82ES", screenX, screenY + screenH + 12);

  ctx.fillStyle = "#7fd3c6";
  ctx.font = "bold 16px Arial";
  ctx.fillText("NATURAL DISPLAY", screenX + screenW - 160, screenY - 8);

  // draw expression + result inside screen
  drawExpression(screenX, screenY, screenW, screenH);
  drawResult(screenX, screenY, screenW, screenH);

  // replay circular pad
  const padCX = W / 2;
  const padCY = screenY + screenH + 55;
  const padR = 40;
  pad.cx = padCX;
  pad.cy = padCY;
  pad.outerR = padR;
  pad.innerR = padR - 8;

  // outer ring
  ctx.beginPath();
  ctx.arc(padCX, padCY, padR, 0, Math.PI * 2);
  ctx.fillStyle = "#5b5a7a";
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "#2c2b3b";
  ctx.stroke();

  // inner ring
  ctx.beginPath();
  ctx.arc(padCX, padCY, padR - 8, 0, Math.PI * 2);
  ctx.fillStyle = "#5f5e80";
  ctx.fill();
  ctx.lineWidth = 1;
  ctx.strokeStyle = "#707090";
  ctx.stroke();

  // arrow symbols
  ctx.fillStyle = "#f5f5f5";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.font = "bold 14px Arial";
  ctx.fillText("▲", padCX, padCY - 20);
  ctx.fillText("▼", padCX, padCY + 22);
  ctx.fillText("◄", padCX - 20, padCY + 2);
  ctx.fillText("►", padCX + 20, padCY + 2);
  ctx.textAlign = "left";
  ctx.textBaseline = "alphabetic";

  // keys layout
  const startY = padCY + 45;
  const startX = margin + 18;
  const colGap = 8;
  const rowGap = 10;
  const keyW = 60;
  const keyH = 34;

  keys.forEach(key => {
    const x = startX + key.col * (keyW + colGap);
    const y = startY + key.row * (keyH + rowGap);
    key.x = x;
    key.y = y;
    key.w = keyW;
    key.h = keyH;

    roundedRect(ctx, x, y, keyW, keyH, 5);
    ctx.fillStyle = key.fill;
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#1e1e28";
    ctx.stroke();

    ctx.fillStyle = key.text;
    ctx.font = "bold 14px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(key.label, x + keyW / 2, y + keyH / 2 + 1);
  });

  // reset text state
  ctx.textAlign = "left";
  ctx.textBaseline = "alphabetic";
}

// --- Expression helpers -----------------------------------------------
function insertText(text) {
  // If we're sitting on a placeholder and typing a single digit/decimal,
  // REPLACE the box instead of inserting before it.
  if (
    expr[cursorPos] === PLACEHOLDER &&
    text.length === 1 &&
    /[0-9.]/.test(text)
  ) {
    expr = expr.slice(0, cursorPos) + text + expr.slice(cursorPos + 1);
    cursorPos += text.length;
  } else {
    expr = expr.slice(0, cursorPos) + text + expr.slice(cursorPos);
    cursorPos += text.length;
  }
}

function deleteChar() {
  if (cursorPos > 0) {
    expr = expr.slice(0, cursorPos - 1) + expr.slice(cursorPos);
    cursorPos--;
  }
}

function clearAll() {
  expr = "";
  result = "";
  cursorPos = 0;
}

// Convert fractions from internal tokens to JS "(/)" form
function convertFractionsToEval(s) {
  let out = "";
  for (let i = 0; i < s.length; i++) {
    const ch = s[i];
    if (ch === FRACTION_START) {
      let sep = -1;
      let end = -1;
      for (let j = i + 1; j < s.length; j++) {
        if (s[j] === FRACTION_SEP && sep === -1) {
          sep = j;
        } else if (s[j] === FRACTION_END) {
          end = j;
          break;
        }
      }
      if (sep === -1 || end === -1) {
        // malformed – skip this token
        continue;
      }
      let num = s.slice(i + 1, sep).replace(new RegExp(PLACEHOLDER, "g"), "");
      let den = s.slice(sep + 1, end).replace(new RegExp(PLACEHOLDER, "g"), "");

      if (!num) num = "0";
      if (!den) den = "1";

      out += "(" + num + ")/(" + den + ")";
      i = end;
    } else if (ch === FRACTION_SEP || ch === FRACTION_END) {
      // shouldn't appear alone – ignore
    } else {
      out += ch;
    }
  }
  return out;
}

// Convert display expr → JS-evaluable string
function buildEvalString() {
  let s = expr;

  // convert structured fractions first
  s = convertFractionsToEval(s);

  // strip any remaining placeholders
  s = s.replace(new RegExp(PLACEHOLDER, "g"), "");

  // implicit multiplication: digit or ")" followed by "("
  s = s.replace(/(\d|\))\(/g, "$1*(");

  // replace nice symbols with JS-friendly ones
  s = s.replace(/×/g, "*")
       .replace(/÷/g, "/")
       .replace(/—/g, "-");

  // square root "√(" -> Math.sqrt(
  s = s.replace(/√\s*\(/g, "Math.sqrt(");

  // exponent: ^ -> **
  s = s.replace(/\^/g, "**");

  return s;
}

function hasDanglingPower() {
  // "^" at end or "^" not followed by a digit
  for (let i = 0; i < expr.length; i++) {
    if (expr[i] === "^") {
      const next = expr[i + 1];
      if (!next || !/[0-9]/.test(next)) return true;
    }
  }
  return false;
}

function evaluateExpression() {
  if (!expr) {
    result = "";
    return;
  }

  if (hasDanglingPower()) {
    result = "Error";
    return;
  }

  let evalStr = buildEvalString();
  try {
    const fn = Function('"use strict"; return (' + evalStr + ');');
    let val = fn();
    if (typeof val === "number" && Number.isFinite(val)) {
      result = String(val);
      lastAnswer = result;
    } else {
      result = "Error";
    }
  } catch (e) {
    result = "Error";
  }
}

// --- Fraction context helper for up/down movement ---------------------
function getFractionContext(pos) {
  for (let i = 0; i < expr.length; i++) {
    if (expr[i] === FRACTION_START) {
      const start = i;
      let sep = -1;
      let end = -1;
      for (let j = i + 1; j < expr.length; j++) {
        if (expr[j] === FRACTION_SEP && sep === -1) {
          sep = j;
        } else if (expr[j] === FRACTION_END) {
          end = j;
          break;
        }
      }
      if (sep === -1 || end === -1) {
        return null;
      }

      if (pos > start && pos < sep) {
        return { start, sep, end, region: "num" };
      }
      if (pos > sep && pos < end) {
        return { start, sep, end, region: "den" };
      }
      if (pos === sep) {
        return { start, sep, end, region: "bar" };
      }
      i = end;
    }
  }
  return null;
}

// --- Handle key labels -------------------------------------------------
function handleKey(label) {
  switch (label) {
    // digits & basic symbols
    case "0": case "1": case "2": case "3":
    case "4": case "5": case "6":
    case "7": case "8": case "9":
    case ".": case "+": case "—":
    case "×": case "÷":
    case "(": case ")":
      insertText(label);
      break;

    // fraction template: structured fraction with two placeholders
    case "a/b":
      insertText(
        FRACTION_START +
        PLACEHOLDER +
        FRACTION_SEP +
        PLACEHOLDER +
        FRACTION_END
      );
      // move cursor into the top box immediately
      cursorPos -= (FRACTION_END.length + PLACEHOLDER.length + FRACTION_SEP.length + PLACEHOLDER.length);
      cursorPos += 1; // inside numerator (after FRACTION_START)
      break;

    // answer recall
    case "Ans":
      if (lastAnswer) insertText(lastAnswer);
      break;

    // clear & delete
    case "AC":
      clearAll();
      break;
    case "DEL":
      deleteChar();
      break;

    // square root -> "√("
    case "√":
      insertText("√(");
      break;

    // x^2 -> "^2"
    case "x²":
      insertText("^2");
      break;

    // x^n -> just "^"
    case "xⁿ":
      insertText("^");
      break;

    // equals -> evaluate expression
    case "=":
      evaluateExpression();
      break;

    // ignoring for now
    default:
      // SHIFT, ALPHA, MODE, SETUP, etc – no-op for now
      break;
  }
}

// --- Mouse interaction: keys + arrow pad ------------------------------
canvas.addEventListener("click", (e) => {
  const rect = canvas.getBoundingClientRect();
  const cssX = e.clientX - rect.left;
  const cssY = e.clientY - rect.top;
  const dpr = window.devicePixelRatio || 1;

  // convert from CSS pixels to canvas pixels
  const canvasX = cssX * dpr;
  const canvasY = cssY * dpr;

  // convert to logical design coordinates
  const mx = (canvasX - offsetX) / scale;
  const my = (canvasY - offsetY) / scale;

  // Check arrow pad ring region first (in logical coords)
  const dx = mx - pad.cx;
  const dy = my - pad.cy;
  const dist = Math.sqrt(dx*dx + dy*dy);

  if (dist <= pad.outerR && dist >= pad.outerR * 0.4) {
    // Rough directional selection
    if (Math.abs(dx) > Math.abs(dy)) {
      // left / right
      if (dx < 0) {
        if (cursorPos > 0) cursorPos--;
      } else {
        if (cursorPos < expr.length) cursorPos++;
      }
    } else {
      // up / down – move between numerator & denominator if in a fraction,
      // otherwise home/end.
      const frac = getFractionContext(cursorPos);
      if (frac) {
        if (dy < 0) {
          // go to numerator slot
          cursorPos = frac.start + 1; // start of numerator
        } else {
          // go to denominator slot
          cursorPos = frac.sep + 1;   // start of denominator
        }
      } else {
        if (dy < 0) {
          cursorPos = 0;           // up -> go to start
        } else {
          cursorPos = expr.length; // down -> go to end
        }
      }
    }
    render();
    return;
  }

  // Otherwise, see if they clicked a key
  for (const key of keys) {
    if (!key.w) continue; // not laid out yet
    if (
      mx >= key.x && mx <= key.x + key.w &&
      my >= key.y && my <= key.y + key.h
    ) {
      handleKey(key.label);
      render();
      return;
    }
  }
});

// --- Keyboard support --------------------------------------------------
document.addEventListener("keydown", (e) => {
  const k = e.key;

  if (k === "ArrowLeft") {
    if (cursorPos > 0) cursorPos--;
    render();
    e.preventDefault();
  } else if (k === "ArrowRight") {
    if (cursorPos < expr.length) cursorPos++;
    render();
    e.preventDefault();
  } else if (k === "ArrowUp") {
    const frac = getFractionContext(cursorPos);
    if (frac) {
      cursorPos = frac.start + 1; // numerator start
    } else {
      cursorPos = 0; // home
    }
    render();
    e.preventDefault();
  } else if (k === "ArrowDown") {
    const frac = getFractionContext(cursorPos);
    if (frac) {
      cursorPos = frac.sep + 1; // denominator start
    } else {
      cursorPos = expr.length; // end
    }
    render();
    e.preventDefault();
  } else if (k === "Backspace") {
    deleteChar();
    render();
    e.preventDefault();
  } else if (k === "Enter" || k === "=") {
    evaluateExpression();
    render();
    e.preventDefault();
  } else if (/[0-9]/.test(k)) {
    insertText(k);
    render();
  } else if (k === "+") {
    insertText("+");
    render();
  } else if (k === "-") {
    insertText("—"); // use the calculator-style minus
    render();
  } else if (k === "*") {
    insertText("×");
    render();
  } else if (k === "/") {
    insertText("÷");
    render();
  } else if (k === ".") {
    insertText(".");
    render();
  } else if (k === "(" || k === ")") {
    insertText(k);
    render();
  } else if (k === "^") {
    insertText("^");
    render();
  }
});

// --- Render loop (for blinking cursor & responsive resize) ------------
function render() {
  const dpr = window.devicePixelRatio || 1;
  const displayWidth  = window.innerWidth;
  const displayHeight = window.innerHeight;

  // Set CSS size
  canvas.style.width  = displayWidth + "px";
  canvas.style.height = displayHeight + "px";

  // Set internal pixel size
  const desiredWidth  = displayWidth * dpr;
  const desiredHeight = displayHeight * dpr;
  if (canvas.width !== desiredWidth || canvas.height !== desiredHeight) {
    canvas.width  = desiredWidth;
    canvas.height = desiredHeight;
  }

  // Reset transform & clear
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Calculate scale to fit DESIGN_* into the canvas while preserving aspect
  scale = Math.min(
    canvas.width  / DESIGN_WIDTH,
    canvas.height / DESIGN_HEIGHT
  );
  offsetX = (canvas.width  - DESIGN_WIDTH  * scale) / 2;
  offsetY = (canvas.height - DESIGN_HEIGHT * scale) / 2;

  // Apply transform
  ctx.translate(offsetX, offsetY);
  ctx.scale(scale, scale);

  // Draw calculator in logical coordinates
  drawCalculator();
}

// Re-render on window resize
window.addEventListener("resize", render);

// Blink cursor
setInterval(() => {
  cursorVisible = !cursorVisible;
  render();
}, 500);

// initial draw
render();
</script>
</body>
</html>
